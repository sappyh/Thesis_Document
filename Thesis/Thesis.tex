\documentclass{kththesis}


\usepackage{blindtext} % This is just to get some nonsense text in this template, can be safely removed
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{csquotes} % Recommended by biblatex
\usepackage[backend=biber]{biblatex}
\usepackage{listings}
\usepackage{algorithmicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[counterclockwise, figuresleft]{rotating}

\addbibresource{stateofart.bib}
\addbibresource{USBMon.bib} % The file containing our references, in BibTeX format

\usepackage{amsmath}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}


\usepackage{pdfpages}

\usepackage{acro}
\usepackage{longtable}

\DeclareAcronym{LPWAN}{
	short=LPWAN,
	long=Low Power Wide Area Network}
	
\DeclareAcronym{sdr}{
  short = SDR,
  long = Software Defined Radio
}

\DeclareAcronym{IO}{
  short = IO,
  long = Input Output
}

\DeclareAcronym{DMA}{
  short = DMA,
  long = Direct Memory Access
}

\DeclareAcronym{csma}{
  short = CSMA,
  long = Carrier Sense Multiple Access
}

\DeclareAcronym{mac}{
  short = MAC,
  long = Medium Access Control
}


\DeclareAcronym{tdma}{
  short = TDMA,
  long = Time Division Multiple Access
}

\DeclareAcronym{cpu}{
  short = CPU,
  long = Central Processing Unit
}

\DeclareAcronym{ack}{
  short = ACK,
  long = Acknowledgement
}

\DeclareAcronym{IOT}{
  short = IoT,
  long = Internet of Things
}

\DeclareAcronym{PHY}{
  short = PHY,
  long = Physical
}

\DeclareAcronym{OSI}{
  short = OSI,
  long = Open Systems Interconnection
}

\DeclareAcronym{RF}{
  short = RF,
  long = Radio Frequency
}

\DeclareAcronym{LQI}{
  short = LQI,
  long = Link Quality Information
}

\DeclareAcronym{FCS}{
  short = FCS,
  long = Frame Control Sequence
}

\DeclareAcronym{CSMA/CA}{
  short = CSMA/CA,
  long = Carrier-sense multiple access with collision avoidance
}

\DeclareAcronym{CSMA/CD}{
  short = CSMA/CD,
  long = Carrier-sense multiple access with collision detection
}

\DeclareAcronym{L2}{
  short = L2,
  long = Layer 2
}

\DeclareAcronym{FPGA}{
  short = FPGA,
  long = Field Programmable Gate Array
}

\DeclareAcronym{DSP}{
  short = DSP,
  long = Digital Signal Processor
}

\DeclareAcronym{NIC}{
  short = NIC,
  long = Network Interface Controller
}

\DeclareAcronym{FPRF}{
  short = FPRF,
  long = Field Programmable RF
}

\DeclareAcronym{UWB}{
  short = UWB,
  long = Ultra Wide Band
}

\DeclareAcronym{LNA}{
  short = LNA,
  long = Low noise amplifier
}

\DeclareAcronym{DDS}{
  short = DDS,
  long = Direct Digital Synthesis
}

\DeclareAcronym{NCO}{
  short = NCO,
  long = Numerically Controlled Oscillator
}


\DeclareAcronym{DAC}{
  short = DAC,
  long = Digital Analog Converter
}


\DeclareAcronym{FIR}{
  short = FIR,
  long = Finite Impulse Response
}

\DeclareAcronym{ASIC}{
  short = ASIC,
  long = Application Specific Integrated Circuit.
}

\DeclareAcronym{PDU}{
  short = PDU,
  long = Packet Data Unit.
}


\DeclareAcronym{MIMO}{
  short = MIMO,
  long = Multiple Input Multiple Output.
}

\DeclareAcronym{SPI}{
  short = SPI,
  long = Serial Peripheral Interface.
}

\DeclareAcronym{PGA}{
  short = PGA,
  long = Programmable Gain Amplifier.
}

\DeclareAcronym{PLL}{
  short = PLL,
  long = Phased Lock Loop
}

\DeclareAcronym{TSP}{
  short = TSP,
  long = Transreceiver Signal Processor}

\DeclareAcronym{IQ}{
  short = IQ,
  long = In-Phase Quadrature.
}

\DeclareAcronym{DDR}{
  short = DDR,
  long = Double Data Rate
}

\DeclareAcronym{FSM}{
  short = FSM,
  long = Finite State Machine
}

\DeclareAcronym{GPIF}{
  short = GPIF,
  long = General Programmable Interface
}

\DeclareAcronym{VHDL}{
 short = VHDL,
 long = VHSIC Hardware Description Language
}

\DeclareAcronym{RTL}{
 short=RTL,
 long= Register Transfer Level
}

\DeclareAcronym{FIFO}{
 short=FIFO,
 long= First In First Out
}

\DeclareAcronym{USB}{
 short=USB,
 long= Universal Serial Bus
}

\DeclareAcronym{I2C}{
 short=I2C,
 long= Inter-Intergrated Circuit
}

\DeclareAcronym{LR-WPAN}{
 short= LR-WPAN,
 long=Low-Rate Wireless Personal Area Network
}

\DeclareAcronym{6LoWPAN}{
 short= 6LoWPAN,
 long=IPV6 over Low-Power Wireless Personal Area Network
}

\DeclareAcronym{O-QPSK}{
 short= O-QPSK,
 long=Offset Quadrature Phase Shift Keying
}

\DeclareAcronym{BPSK}{
 short= BPSK,
 long= Binary Phase Shift Keying
}
\DeclareAcronym{ASK}{
 short= ASK,
 long= Amplitude Shift Keying
}
\DeclareAcronym{CSS}{
 short= CSS,
 long= Chirp Spread Spectrum
}

\DeclareAcronym{GTS}{
 short= GTS,
 long= Guaranteed Time Slot
}

\DeclareAcronym{PAN}{
 short= PAN,
 long= Personal Area Network
}

\DeclareAcronym{FFD}{
 short= FFD,
 long= Full Function Device
}

\DeclareAcronym{RFD}{
 short= RFD,
 long= Reduced Function Device
}

\DeclareAcronym{CRC}{
 short= CRC,
 long= Cyclic Redundancy Check
}

\DeclareAcronym{SHR}{
 short= SHR,
 long= Synchronization Header
}

\DeclareAcronym{SFD}{
 short= SFD,
 long= Start-of-Frame Delimiter
}

\DeclareAcronym{PN}{
 short= PN,
 long= Pseudo Noise
}

\DeclareAcronym{PCIe}{
 short = PCIe,
 long= Peripheral Component Interconnect Express
}

\DeclareAcronym{API}{
 short = API,
 long= Application Programming Interface
}

\DeclareAcronym{ARQ}{
 short = ARQ,
 long= Automatic Repeat reQuest
}

\DeclareAcronym{GPMC}{
 short = GPMC,
 long= General Purpose Memory Controller
}

\DeclareAcronym{UHD}{
 short = UHD,
 long= USRP Hardware Driver
}

\DeclareAcronym{RAT}{
 short = RAT,
 long= Radio Access Technology
}

\begin{document}

%\acsetup{first-long-format=\itshape}


% Frontmatter includes the titlepage, abstracts and table-of-contents
\frontmatter

\includepdf[pages={1}]{Chapters/cover.pdf}
%\titlepage

\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\tableofcontents
\listoffigures
\listoftables

\clearpage

\acsetup{list-style=longtable, list-heading=chapter*}
\printacronyms[ heading= chapter*, sort=true]

%[
% name = {Abbreviations},
% sort = true,
%]

%\input{Chapters/acronym.tex}
\mainmatter

% Mainmatter is where the actual contents of the thesis goes


\input{Chapters/introduction.tex}
\input{Chapters/Background.tex}
\input{Chapters/Literature.tex}
\input{Chapters/Methods.tex}



\chapter{Results and Analysis}
\subsection{Analytical Method}
The 802.15.4 PHY layer expands 1 byte of message data to 128 bytes, so the maximum packet length of 127 bytes becomes produces sample data of size
$127*128=16256 bytes=15.875KB$\\. The FPGA packet format adds 16 bytes overhead for every 4080 bytes so the overhead for 16256 bytes would be 64bytes. So the overall transfer size would be 16320 bytes. This would require four FPGA packets so the actual size of the USB transfer would be 16384 bytes
Now for sampling rate of 1MHz $\equiv$ 1MSPS, the actual data transfer is 1.5 MBps since the LMS7002M has 12 bits ADC and DAC. 
\begin{table}[!h]
\centering
\begin{tabular}{|c|c|}
\hline
Sampling Rate & USB Transfer delay \\
\hline
5 MHz & 4369.07 $\mu$s\\
10 MHz & 2184.53 $\mu$s\\
15 MHz & 1456.35 $\mu$s\\
20 MHz & 1092.27 $\mu$s\\
\hline
\end{tabular}
\caption{Analytical USB Transfer Delay}
\label{back_env}
\end{table}

\subsection{Experimental Results}
\begin{figure}
\centering
\includegraphics[scale=0.5]{Figure/results_setup.png}
\caption{Results Setup}
\label{res_set}
\end{figure}
Figure \ref{res_set} shows the different terminology used in the results, with the TX \& RX software delay is the delay caused by the GNU Radio and LimeSDR driver processing, the Kernel RTT Time includes the buffer delay in the LimeSDR and the USB communication delay. Total RTT Time = Kernel RTT Time + TX Software Delay + RX Software Delay. All the timing measurements are done on Lenovo Thinpad X240 with Dual-Core Intel® Core™ i5-4300U CPU @ 1.90GHz and 4GB RAM. The setup use Limesuite version 17.12.0 and gateware version 2.12.
\begin{table}
\centering
\label{res}
\begin{tabular}{|l|c|c|c|c|}
\hline
Sampling Rate(MHz)                                                  & 5    & 10   & 15   & 20   \\
\hline
Total RTT mean ($\mu$s)                                                      & 5360 & 3606 & 3065 & 4485 \\ \hline
Total RTT std deviation ($\mu$s)   & 326  & 472  & 262  & 1273 \\ \hline
Kernel RTT mean ($\mu$s)                                                     & 4113 & 1937 & 1354 & 762  \\ \hline
Kernel RTT std deviation ($\mu$s) & 1201 & 330  & 232  & 298  \\ \hline
TX chain mean ($\mu$s)                                                       & 470  & 675  & 831  & 1586 \\ \hline
TX chain std deviation ($\mu$s)    & 60   & 1165 & 186  & 860  \\ \hline
RX chain mean ($\mu$s)                                                       & 1100 & 1122 & 871  & 1769 \\ \hline
RX chain std deviation ($\mu$s)                                              & 472  & 1764 & 262  & 1036\\ \hline
\end{tabular}
\caption{Experimental results}
\end{table}



\subsection{Analysis}
\begin{itemize}
\item {The results show a monotonic drop in the kernel USB timings with increase in sampling rate and monotonic increase for RX and TX delay (Exception: 15 MHz). This indicates with increase in sampling rate, the buffers are getting overloaded and hence an increase in processing delay compared to bus communication delay.}
\item {Another thing that I noticed was at high sampling rate the round trip time increases with time, again pointing to buffer delay on the RX chain.}
\item {My measurement program becomes highly unstable at higher sampling rates, for example for 20MHz, I captured 610 packets of which I could correlate only 160 packets. This is mainly because the usbmon event queues overflow and hence my timing measurement program misses some relevant events and reports wrong timing information. One method I plan on using is flushing the buffers before the message source generates the message since each measurement is independent of the previous in a TDMA protocol.  }
\item {The analytical values for the RTT time( Table \ref{back_env}) is more than the actual value that usbmon reported(Table \ref{res}), my hypothesis is that this happens due to my assumption that all the data in the LimeSDR TX buffer is popped before the relevant RX data is popped back in the RX buffers on the LimeSDR side. But in actual operation even before all the TX data has been popped, the loopback data is being pushed to the RX buffers. This is demonstrated using figure \ref{staggering} where its shows the state of the RX and TX buffers with respect to time. \textit{t1} shows the instant when all the relevant data has been popped from the TX buffers and \textit{t2} shows the instant when the relevant RX data is popped from the buffers. For my assumption \textit{t1} should be equal to \textit{t2}, but here  $t2<t1$ hence the reported values are less than those of the analytical model. With increase in sampling rate the difference between t2 and t1 increases. There is a need to address this issue to ensure reliability of the measurement method.
\begin{figure}
\centering
\hspace{1cm}\includegraphics[scale=0.5]{Figure/Staggering.png}
\caption{Overlapping of buffers on LimeSDR}
\label{staggering}
\end{figure}
}
\end{itemize}

\printbibliography[heading=bibintoc] % Print the bibliography (and make it appear in the table of contents)

\appendix

% \chapter{Unnecessary Appended Material}

\includepdf[pages={2}]{Chapters/cover.pdf}
\end{document}
